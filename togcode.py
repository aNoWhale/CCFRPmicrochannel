# def commands_for_one_layer(points, n):
#     # Add G1, X, Y values
#     gcode = zig.output_gcode(points)
#     gcode_coordinates = re.get_coordinates_from_gcode(gcode)
#     distances = re.calculate_distances(gcode_coordinates)
#     for distance in distances:
#         evalue = float(distance)
#         evalues.append(evalue)
#     # Add U, V values and cutting of fibers
#     results = sgc.reprogram_gcode_center_evalue_layer(gcode, new_center, evalues, n, num, layer_height, jump, length)
#     # Cut fibers in specific index of points
#     # gcode_lines, cut = cut_fiber.cut_fiber_endtail_layer(even_points)
#     return results
import math
from gcodeparser import GcodeParser

kuv = 0.055  # v=kuv*u


def points_to_G1(pointsxyz, layer_height=1, speedcontrol=False, minspeed=100, maxspeed=300, brakespace=3):
    """
    pointsxyz list to gcode
    :param brakespace: length before end of long line
    :param maxspeed:
    :param minspeed:
    :param speedcontrol: true to enable speedcontrol
    :param pointsxyz: list [x,y,z]
    :param layer_height: if layer_height = 1, path height will be defined by z, else = z *layer_height
    :return:
    """

    new_all_gcode = []
    start = [";generated by points_to_G1" + "\n", "G1 Z" + str('%.2f' % (layer_height)) + "\n", "G92 U0 V0" + "\n"]
    new_all_gcode.extend(start)
    d = 0
    for i in range(0, len(pointsxyz)):
        # 1013：求两点间距离
        if i != 0:
            x1, y1, z1 = pointsxyz[i - 1]
            x2, y2, z2 = pointsxyz[i]
            # 注意 gcode中z=path.z*layheight，距离中并没有这一环，要在这里处理
            z1 = z1 * layer_height
            z2 = z2 * layer_height
            x_ = (x2 - x1)
            y_ = (y2 - y1)
            z_ = (z2 - z1)
            unitd = math.sqrt(x_ ** 2 + y_ ** 2 + z_ ** 2)  # 单步distance
            d += unitd
            if speedcontrol is True:
                if unitd > brakespace:
                    # 对于循环来说，目前x1已经写入gcode x2尚未写入
                    # 对于已写入的x1,在下一行添加F参数
                    # new_all_gcode[len(new_all_gcode) - 1] = new_all_gcode[len(new_all_gcode) - 1] + " " + "F" + str(
                    #     maxspeed)
                    addg1 = ("G1" + " " + "F" + str(maxspeed))
                    new_all_gcode.append(addg1)
                    factor = brakespace / unitd
                    # 长度
                    dx = x_ * factor
                    dy = y_ * factor
                    dz = z_ * factor
                    # 坐标
                    # 注意z=path.z*layheight已经处理完了，gcode不应再处理了
                    xsp = x2 - dx
                    ysp = y2 - dy
                    zsp = z2 - dz
                    dab = d - brakespace
                    speedcontrol_gcode1 = ("G1 X" + str('%.3f' % xsp) + " " +
                                           "Y" + str('%.3f' % ysp) + " " +
                                           "Z" + str('%.3f' % zsp) + " " +
                                           "U" + str('%.3f' % dab) + " " +
                                           "V" + str('%.3f' % (dab * kuv)))
                    new_all_gcode.append(speedcontrol_gcode1)
                    speedcontrol_gcode2 = ("G1" + " " + "F" + str(minspeed))
                    new_all_gcode.append(speedcontrol_gcode2)
                    # 实现了在到达直线末端前brakespace距离时减速
        next_gcode = ("G1 X" + str('%.3f' % (pointsxyz[i][0])) + " " +
                      "Y" + str('%.3f' % (pointsxyz[i][1])) + " " +
                      "Z" + str('%.3f' % (layer_height * pointsxyz[i][2])) + " " +
                      "U" + str('%.3f' % d) + " " +
                      "V" + str('%.3f' % (d * kuv)))
        new_all_gcode.append(next_gcode)
    return new_all_gcode


def change_extruder():
    changextruder = ["; Start change extruder",
                     "M400",  # 等待移动完成
                     "G1 F1800 V9.74010",  # ？
                     "M104 S235 T0",  # 设置热端温度
                     "G0 Z5.175 F1500",  # ?
                     "M1013 ",  # ？
                     "M104 S180 T1",  # 设置热端温度
                     "M400",  # 等待移动完成
                     "M106 P1 S0",  # 设置风扇速度
                     "M109 S265 T0",  # 等待热端加热至目标温度
                     "T0 ; switch extruder ",  # 切换至T0
                     "M1013 R ",  # ？
                     "; End change extruder "]


def cut_fiber():
    cutfiber = ["M400", "M280 P0 S30", "G4 P200", "M280 P0 S90", "M400"]


def write_gcode_to_file(gcode_lines, output_file):
    # Write gode to file
    with open(output_file, "w") as file:
        head = [";--- Start G-code Begin ---",
                "U is the distance of the coordinates and V is 0.055 times smaller than U.",
                "M104 S275 T1",
                "M140 S60",
                "G21",
                "G90",
                "M82",
                "G28",
                "M530 S1",
                "G1 Z10 F900",
                "; Start change extruder",
                "M400",
                "M109 S275 T1",
                "T1 R ; switch extruder",
                "; End change extruder",
                "G92 E0 ; reset extrusion",
                "G92 V0 ; reset extrusion",
                "G92 U0 ; reset extrusion",
                "M190 S60",
                "M400",
                "M106 P1 S127",
                "G1 F300",
                ";--- Start G-code End -"]

        end = [";--- End G-code Begin ---",
               # "M400",
               # "M280 P0 S30",
               # "G4 P200",
               # "M280 P0 S90",
               # "M400",
               "M104 S0 T0",
               "M104 S0 T1",
               "M106 P1 S0",
               "M140 S0",
               "G91",
               "G1 Z20 F900",
               "G90",
               "G28",
               "M530 S0",
               "M204 S1000",
               "M107",
               "M104 S0",
               "M140 S0",
               "G92 E0",
               "G1 E-2 F3000",
               "G92 E0",
               "G28",
               "M104 S0",
               ";--- End G-code End ---"]

        # Generate Gcode with multiple layers
        for he in head:
            file.write(he + "\n")
        for line in gcode_lines:
            # for lin in line:
            #     if lin.split():
            file.write(line + "\n")
        for en in end:
            file.write(en + "\n")


def reduce_points(pointsxyz: list):
    reduced = []
    direction = ""
    for i in range(1, len(pointsxyz)):
        lastpoint = pointsxyz[i - 1]
        thispoint = pointsxyz[i]
        dx = lastpoint[0] - thispoint[0]
        dy = lastpoint[1] - thispoint[1]
        dz = lastpoint[2] - thispoint[2]
        if dx != 0 and dy == 0 and dz == 0:
            if direction == "x":
                pass
            else:
                reduced.append(lastpoint)
                direction = "x"
        if dx == 0 and dy != 0 and dz == 0:
            if direction == "y":
                pass
            else:
                reduced.append(lastpoint)
                direction = "y"
        if dz != 0 and dx == 0 and dy == 0:
            reduced.append(lastpoint)
            if direction == "z":
                pass
            else:
                reduced.append(lastpoint)
                direction = "z"
        if dx != 0 and dy == 0 and dz != 0:
            if direction == "?":
                pass
            else:
                reduced.append(lastpoint)
                direction = ""
        if dx == 0 and dy != 0 and dz != 0:
            if direction == "?":
                pass
            else:
                reduced.append(lastpoint)
                direction = ""
        if dx != 0 and dy != 0:
            reduced.append(lastpoint)
            direction = ""
    reduced.append(pointsxyz[len(pointsxyz) - 1])
    return reduced
